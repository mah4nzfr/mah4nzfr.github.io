---
title: Sommer Remotes and Rolling Codes (Part 1) - Project
date: 2025-03-07 12:54:00 +0330
categories: [Project]
tags: [hardware,RF]
description: An analyzation of packets transmitted from the remotes and how to replay them

---

We all have used remotes of all kind, to control devices such as a TV, AC, or even doors. Today I'll be focusing on some specific garage door opener remotes from Sommer, which use **rolling codes** to prevent **replay attacks**.  
Normal RF remotes have **static codes** that do not change, and no matter how many times you press the button, the same code gets transmitted. However, rolling codes are actually a series of bits which both the transmitter and the receiver have knowledge about.   
To put it this way, the transmitter will send `1122` at first, then `3344`and after that `5566`. The receiver knows about the algorithm and the series of numbers that will be sent. Now the if it receives the first number, it won't acknowledge `1122` anymore and the code is now considered expired until the series loops (they all loop but after a very very long time).  
As you might have guessed, static codes are pretty damn easy to replay, even if you don't know the modulation and encoding of the packet, you can easily sniff the packet raw (using a timed interval such as 100us) and replay it the same way. Again, because some part of the packet is constantly changing, replaying the packet will only work once (if the sniffed packet was not already intercepted by the reciever).  
One method of acquiring a valid code for yourself is **Rolljam**. The process is as follows:
1. Jam the frequency so that the intended receiver doesn't receive the packet (The jamming here is tricky as you have to send gibberish some MHz lower so YOU, the attacker, can sniff the packet but the victim device can't see it).
2. Capture the first transmitted packet.
3. Now because e.g. the car doors are still locked, the owner will press the remote again, now capture the second transmitted packet.
4. You will send the first captured packet so that the vehicle unlocks. 

and viola! you got yourself an unused key to take advantage of later XD.  
Another method (and a more efficient one) is to find the rolling algorithm, and this idea was the kickstarter of this research.  
I Captured the packets from **Sommer TX03-868-4** remote with a **CC1101** module connected to an **ESP32**.  
Configuration:  
- Frequency: `868.8 MHz`  
- Modulation: `2-FSK`  
- Bandwidth: `270.83 KHz`  
- Deviation: `47.60 KHz`  
This conf is also known as `FM 4760`.  
Here is an example of a captured frame:
```
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000011100000111100000111000000111000000111000001110000001110000011100000011100000011100
000111000000111000000000000000000000000000000000000000000001111111100000111000000000011111111000001111111100000111000000
000011100000000001111111000000111000000000011111110000001110000000000111000000000011100000000011110000000000111000000000
111111110000011110000000001110000000000111111110000011100000000001111111100000111000000000011100000000001110000000000111
000000000011111110000001110000000000111000000000011100000000001110000000001111000000000011100000000011111111000001111000
000000111000000000011111111000001110000000000111000000000011100000000001111111000000111111110000011111111000001111111000
000111000000000011111110000001110000000000111000000000011111110000011110000000000111000000000111100000000011110000000001
111111100000111111110000011111111000001110000000000111000000000011100000000001111111100000111111100000011111110000001111
111000000111111100000011100000000001111111000000111111100000011100000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
001110000001110000011100000011100000011100000111000000111000001111000001110000001110000011110000011100000000000000000000
000000000000000000000000111111110000011110000000001111111100000111111110000011100000000001110000000000111111110000011100
000000001111111000000111000000000011100000000001110000000000111000000000011100000000011111111000001111000000000111100000
000011111111000001111000000000111111110000011100000000001110000000000111000000000011100000000001111111000000111000000000
011100000000001110000000000111000000000011100000000001110000000000111111100000011100000000011110000000000111111100000111
100000000011100000000001111000000000111111110000011111111000001111111100000111111110000011100000000001111111000000111000
000000011100000000001111111000000111000000000011100000000001110000000000111000000000011111110000001111111000001111111100
000111100000000011110000000001111000000000111111110000011111111000001111111100000111111110000011111111000001111000000000
111111110000011111111000001110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011100000111000000111000001111000
001110000001110000011110000011100000111100000111100000111000001111000000000000000000000000000000000000000000001111111100
000111000000000011111110000001111111000000111000000000011100000000001111111000000111000000000011111110000001110000000000
111000000000111100000000001110000000000111000000000111111110000011110000000001111000000000111111110000011110000000001111
111100000111100000000011100000000001110000000000111000000000011111111000001110000000000111000000000011100000000001110000
000000111000000000011100000000001111111000000111000000000011100000000001111111000000111000000000011100000000001110000000
000111111100000111111110000001111111000000111111100000111100000000011111111000001111000000000111000000000011111111000001
110000000000111000000000011100000000001110000000000111111110000011111111000001111111100000111000000000011100000000001110
000000000111111100000011111111000001111111000000111111100000011111110000001110000000000111111100000011111110000001110000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000111000000111000000111000001110000001110000011110000011100000011100
000111000000111000000111000001110000000000000000000000000000000000000000000001111111000000111000000000011111110000001111
111000000111000000000011100000000001111111000000111000000000111111110000001110000000001111000000000011100000000001110000
000001111000000000111111110000011100000000001110000000000111111110000011100000000001111111100000111000000000011100000000
001110000000000111000000000011111110000001110000000000111000000000011100000000001110000000000111000000000011100000000001
111111000000111000000000011100000000001111111000000111000000000011100000000001110000000000111111100000011111111000001111
111000000111111100000011100000000001111111000000111000000000011100000000001111111000000111000000000011100000000001110000
000000111000000000011111110000001111111000000111111100000011100000000001110000000000111000000000011111110000001111111000
000111111100000011111110000001111111000000111000000000011111110000001111111000000111000000000000000000
```

After a bit of research and some trial and error, I managed to convert the raw frame to the actual binary frame, and also wrote a script to automate the process. The above set of 1s and 0s, is actually this:

```
000000000000
101100101000001001010000100000010010001111010010000111000111110110
000000000000
101100101000001001010000100000010010001111010010000111000111110110
000000000000
101100101000001001010000100000010010001111010010000111000111110110
000000000000
10110010100000100101000010000001001000111101001000011100011111011
```

Here are some more examples:

```
000000000000
110001001100001001000111011100110010001111010010000111000111111010
000000000000
110001001100001001000111011100110010001111010010000111000111111010
000000000000
110001001100001001000111011100110010001111010010000111000111111010
000000000000
110001001100001001000111011100110010001111010010000111000111111010
000000000000
110001001100001001000111011100110010001111010010000111000111111010
000000000000
110001001100001001000111011100110010001111010010000111000111111010
```

```
000000000000
000011011101110000001111110111010010001111010010000111000111011110
000000000000
000011011101110000001111110111010010001111010010000111000111011110
000000000000
000011011101110000001111110111010010001111010010000111000111011110
000000000000
000011011101110000001111110111010010001111010010000111000111011110
000000000000
000011011101110000001111110111010010001111010010000111000111011110
```

Did you notice the pattern? All of them start with the 12 bit of zeroes, then the command and repeates. The 12 zeroes are a delimiter, the first 32 bits of the command section is the rolling part, the next 32 bits are address and command bits and we have `10` at the end. The last two bits are either there to mark the end of packet or the packet is really 66 bits! (which would be odd)  
Now to demonstrate better, here are 9 consecutive packets:
```
00011010100101010101110111000000 00100011110100100001110001111011 10 # button A

10110010100000100101000010000001 00100011110100100001110001111101 10 # button B

11000100110000100100011101110011 00100011110100100001110001111110 10 # button C

00001101110111000000111111011101 00100011110100100001110001110111 10 # button D

01100110011010000100001000010111 00100011110100100001110001111011 10 # button A

00110011010011110100011011001000 00100011110100100001110001111011 10 # button A

01010011111110001010100000110001 00100011110100100001110001111011 10 # button A

00000001001110011110110100100111 00100011110100100001110001111011 10 # button A
```
I discovered the algorithm of rolling code generation in these type of remotes are similar to pseudo random number generation, meaning all we need is the **Seed**. 
For now I have not been successful at acquiring the seed, as I need to inspect the hardware of the reciever closely and sadly, I do not have that on hand.  
Given the circumstance, I have decided to try and predict the sequence with the help of **Machine Learning**. I also plan to implement the ML model inside a  STM32H7 microcontroller  or a Raspberry pi so that we can predict and replay the packet on the fly.